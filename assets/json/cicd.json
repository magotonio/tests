[
  {
    "nombre": "test01",
    "test": [
      {
        "pregunta": "¿Cuáles son los tres aspectos de ALM?",
        "resp": [
          {
            "texto": "Gobierno, integración y despliegue."
          },
          {
            "texto": "Gobierno, desarrollo y operaciones."
          },
          {
            "texto": "SDLC,CICD y despliegue continuo."
          },
          {
            "texto": "Desarrollo y operaciones."
          }
        ],
        "correct": 1,
        "feedback": "Estos tres aspectos forman parte del ciclo de ALM e intervienen en cada una de las fases, según corresponda."
      },
      {
        "pregunta": "¿Qué significa construir, probar y desplegar automáticamente?",
        "resp": [
          {
            "texto": "Escribir unos scripts de bash para cada tarea."
          },
          {
            "texto": "Definir trabajos en Jenkins y ejecutarlos cada vez que hay un cambio."
          },
          {
            "texto": "Documentar cada paso del despliegue exhaustivamente."
          },
          {
            "texto": "Conseguir que los cambios de código inicien una construcción, ejecuten las pruebas y permitan un despliegue sin intervención humana."
          }
        ],
        "correct": 3,
        "feedback": "Las respuestas $0 y $1 son ciertas en parte, pero no son suficientes de manera individual para desplegar automáticamente."
      },
      {
        "pregunta": "¿Por qué es útil desplegar un entorno de producción antes de que acabe el desarrollo?",
        "resp": [
          {
            "texto": "Para probar el proceso de despliegue antes de la fecha clave."
          },
          {
            "texto": "Para comprobar que el sistema funciona bien en este entorno, que puede ser y será diferente de los entornos de desarrollo."
          },
          {
            "texto": "Para aumentar la fiabilidad del proceso."
          },
          {
            "texto": "Todas las anteriores."
          }
        ],
        "correct": 3,
        "feedback": "Aunque pueden existir razones de costes para no desplegar en producción mucho antes de la salida al mercado, desplegar en un entorno similar a producción es clave para conseguir un proceso de despliegue fiable."
      },
      {
        "pregunta": "¿Qué significa gestionar automáticamente la configuración?",
        "resp": [
          {
            "texto": "Mantener la configuración de cada entorno separada del script de despliegue y con un control de versiones."
          },
          {
            "texto": "Escribir scripts separados, uno por entorno, que no dependan de ningún otro fichero."
          },
          {
            "texto": "Guardar la configuración aplicada en cada entorno en una base de datos."
          },
          {
            "texto": "Ninguna de las anteriores."
          }
        ],
        "correct": 0,
        "feedback": "Es fundamental que todos los entornos se desplieguen con el mismo proceso y que la configuración específica se guarde por separado."
      },
      {
        "pregunta": "¿Cuál es el objetivo de la integración continua?",
        "resp": [
          {
            "texto": "Obligar a los desarrolladores a integrar cambios todos los días para controlar lo que hacen."
          },
          {
            "texto": "Implantar una herramienta moderna como Jenkins."
          },
          {
            "texto": "Aumentar la calidad del código detectando los errores lo más pronto posible y la velocidad a la que se entrega a los clientes."
          },
          {
            "texto": "Ninguna de las anteriores."
          }
        ],
        "correct": 2,
        "feedback": "El objetivo principal es aumentar la calidad del código ofrecido a los clientes, ya que es el único sitio en el que aporta valor."
      },
      {
        "pregunta": "¿Cuál es el objetivo de la entrega continua?",
        "resp": [
          {
            "texto": "Aumentar la fiabilidad del código, reduciendo el número de errores."
          },
          {
            "texto": "Reducir el tiempo necesario para entregar software en producción."
          },
          {
            "texto": "Aumentar la fiabilidad de los procesos de despliegue."
          },
          {
            "texto": "Todas las anteriores."
          }
        ],
        "correct": 3,
        "feedback": "Cuando se consiguen todos los objetivos anteriores, el resultado es el código de calidad que aporta valor al producto lo más rápido posible."
      },
      {
        "pregunta": "¿Qué diferencia hay entre entrega y despliegue continuos?",
        "resp": [
          {
            "texto": "Ninguna, son sinónimos."
          },
          {
            "texto": "La entrega deja el producto listo para desplegar después de cada cambio, pero no tiene por qué desplegar en producción. El despliegue continuo prosigue el flujo de la entrega múltiples veces al día hasta completar el despliegue en producción."
          },
          {
            "texto": "La entrega solo compila el código, el despliegue, además, incorpora las pruebas."
          },
          {
            "texto": "Ninguna de las anteriores."
          }
        ],
        "correct": 1,
        "feedback": "Puede haber razones de negocio o técnicas para implementar entrega continua sin despliegue continuo."
      },
      {
        "pregunta": "¿Qué se puede esperar de las construcciones de software en una organización que no ha empezado a madurar en la integración continua?",
        "resp": [
          {
            "texto": "El pase a producción es automático, fiable e indoloro."
          },
          {
            "texto": "Los cambios en la base de datos se ejecutan manualmente."
          },
          {
            "texto": "La construcción es manual y no se gestionan los artefactos."
          },
          {
            "texto": "No hay batería de pruebas alguna."
          }
        ],
        "correct": 2,
        "feedback": "Además, los despliegues son manuales, no hay un proceso común de despliegue, las pruebas no están integradas en el desarrollo y las migraciones de las bases de datos no están versionadas y se ejecutan manualmente."
      },
      {
        "pregunta": "¿En qué debe centrar sus esfuerzos una organización que intenta mejorar su calidad de software?",
        "resp": [
          {
            "texto": "En aquellos aspectos del proceso de integración y entrega que sean más dolorosos."
          },
          {
            "texto": "En automatizar todo el proceso cuanto antes."
          },
          {
            "texto": "En desplegar la aplicación sobre Kubernetes."
          },
          {
            "texto": "En versionar todos los elementos de la configuración."
          }
        ],
        "correct": 0,
        "feedback": "Aquellos aspectos más dolorosos y que más riesgo introducen serán los que más valor puedan aportar si se mejoran. Poco a poco se podrán ir mejorando otros aspectos."
      },
      {
        "pregunta": "¿Cuál de estos elementos es fundamental para empezar a aplicar integración continua?",
        "resp": [
          {
            "texto": "Un sistema de control de versiones."
          },
          {
            "texto": "Una batería de pruebas y automatización."
          },
          {
            "texto": "Aceptación del equipo."
          },
          {
            "texto": "Todos los anteriores."
          }
        ],
        "correct": 3,
        "feedback": "Todos los elementos citados, tanto técnicos como humanos, son esenciales para implementar integración continua en un proyecto."
      }
    ]
  },
  {
    "nombre": "test02",
    "test": [
      [
        {
          "pregunta": "¿En qué consiste un commit?",
          "resp": [
            {
              "texto": "Es el proceso de incluir un fichero en un sistema de control de cambios."
            },
            {
              "texto": "Es un conjunto de cambios registrados en la historia de un sistema de control de cambios."
            },
            {
              "texto": "Es una carpeta con los ficheros de una versión de la aplicación."
            },
            {
              "texto": "Es el cambio a un punto anterior de la historia del repositorio."
            }
          ],
          "correct": 1,
          "feedback": "Los cambios pueden ser modificaciones de líneas en ficheros existentes (nuevas líneas, líneas eliminadas o modificadas), ficheros añadidos o eliminados del repositorio. Algunos sistemas detectan el renombrado de ficheros como un cambio en sí mismo, otros consideran un renombrado cuando desaparece un fichero y se añade uno nuevo."
        },
        {
          "pregunta": "¿Qué debería ser versionado?",
          "resp": [
            { "texto": "El código fuente de la aplicación." },
            { "texto": "La documentación." },
            { "texto": "Las herramientas de despliegue." },
            { "texto": "Todos los anteriores." }
          ],
          "correct": 3,
          "feedback": "Es fundamental ser capaz de reproducir una versión de la aplicación y esto no se consigue solo con el código fuente. Son necesarios también los scripts de despliegues, las dependencias, herramientas, etc."
        },
        {
          "pregunta": "¿En qué consiste la edición simultánea?",
          "resp": [
            {
              "texto": "Varios desarrolladores editan un mismo fichero y uno de ellos combina los cambios del resto manualmente."
            },
            {
              "texto": "Un desarrollador bloquea un fichero para trabajar sobre él."
            },
            {
              "texto": "Varios desarrolladores trabajan sobre el mismo repositorio y probablemente sobre los mismos ficheros y el sistema se encarga de fusionar los cambios de todos automáticamente."
            },
            { "texto": "Ninguna de las anteriores." }
          ],
          "correct": 2,
          "feedback": "En algunos casos es necesario corregir conflictos manualmente."
        },
        {
          "pregunta": "Relaciona el concepto con su definición.",
          "resp": [],
          "options": ["Commit.", "Rama.", "Repositorio.", "Fusión."],
          "rels": [
            "Conjunto de cambios registrados en la historia.",
            "Puntero a un conjunto de cambios consecutivos.",
            "Almacén de los cambios de un sistema o aplicación.",
            "Unión de dos ramas."
          ],
          "feedback": "Respuesta correctaRespuesta correcta"
        },
        {
          "pregunta": "¿Qué significa «viajar en el tiempo» en el contexto de los sistemas de control de versiones?",
          "resp": [
            {
              "texto": "Que se pueden instalar versiones antiguas de una aplicación."
            },
            {
              "texto": "Que las nuevas versiones son compatibles con las anteriores."
            },
            {
              "texto": "Que un desarrollador puede trabajar en una versión antigua del repositorio."
            },
            { "texto": "Ninguna de las anteriores." }
          ],
          "correct": 2,
          "feedback": "Más concretamente, la copia de trabajo se puede actualizar con cualquier commit del histórico."
        },
        {
          "pregunta": "¿Qué metadatos incluyen los commits?",
          "resp": [
            { "texto": "Autor." },
            { "texto": "Fecha." },
            { "texto": "Comentarios." },
            { "texto": "Todos los anteriores." }
          ],
          "correct": 3,
          "feedback": "También incluyen un identificador único, pueden incluir una firma, etc."
        },
        {
          "pregunta": "¿Cómo se recomienda versionar las dependencias de una aplicación?",
          "resp": [
            {
              "texto": "Copiando el código fuente de la dependencia dentro de una carpeta del repositorio de la aplicación."
            },
            {
              "texto": "Manteniendo un documento con instrucciones sobre cómo instalarla."
            },
            {
              "texto": "Referenciando la versión de la dependencia como una librería e instalándola con un gestor de paquetes durante el despliegue."
            },
            { "texto": "Todas los anteriores son estrategias válidas." }
          ],
          "correct": 2,
          "feedback": "Técnicamente, todas las opciones son posible, pero la $0 no permite actualizar la versión de la dependencia fácilmente y la $1 no tiene en cuenta una instalación automatizada."
        },
        {
          "pregunta": "¿Cómo se crea una nueva rama llamada feature en Git?",
          "resp": [
            { "texto": "git checkout -b feature." },
            { "texto": "git branch feature." },
            { "texto": "git create branch feature." },
            { "texto": "$0 y $1." }
          ],
          "correct": 3,
          "feedback": "«$0» crea la rama y la activa en la copia de trabajo, mientras que «$1» la crea, pero no cambia la rama activa."
        }
      ]
    ]
  },
  {
    "nombre": "test03",
    "test": [
      {
        "pregunta": "¿Por qué un sistema de control de versiones distribuido no necesita bloqueo de archivos?",
        "resp": [
          { "texto": "Sí que lo necesita." },
          {
            "texto": "Porque cada usuario trabaja con una copia completa del repositorio."
          },
          { "texto": "Porque son sistemas más antiguos y limitados." },
          {
            "texto": "Porque cada usuario es propietario de un fichero y solo ese usuario puede modificarlo."
          }
        ],
        "correct": 1,
        "feedback": "Cada usuario puede, por tanto, trabajar en todos los ficheros que necesite; el sistema se encargará de fusionar los cambios automática o de avisar al usuario si hay conflictos que se deben resolver manualmente."
      },
      {
        "pregunta": "¿Por qué no se puede aplicar el flujo de GitHub en un sistema de control de versiones centralizado?",
        "resp": [
          { "texto": "Técnicamente se puede, aunque no es habitual." },
          {
            "texto": "Porque solo funciona con GitHub, que se basa en Git, que es un sistema de control de versiones distribuido."
          },
          {
            "texto": "Porque se basa en los conceptos de fork y pull requests, que solo ofrecen los sistemas distribuidos."
          },
          { "texto": "Ninguna de las anteriores." }
        ],
        "correct": 2,
        "feedback": "El flujo de GitHub se puede aplicar en otras plataformas, como BitBucket y GitLab."
      },
      {
        "pregunta": "¿Cuántas ramas soporta el flujo centralizado?",
        "resp": [
          { "texto": "Solo una, master o trunk." },
          {
            "texto": "Solo una en el repositorio principal y tantas como sean necesarias en los forks."
          },
          { "texto": "Una principal y una de desarrollo." },
          {
            "texto": "Una principal, una de desarrollo y tantas como sean necesarias para las funcionalidades nuevas."
          }
        ],
        "correct": 0,
        "feedback": "Es el flujo más cercano al concepto de integración continua extrema, ya que todos los cambios se añaden a la rama principal directamente."
      },
      {
        "pregunta": "¿Por qué una rama de hotfix se fusiona tanto a master como a develop en el Gitflow?",
        "resp": [
          { "texto": "Solo se fusiona a master, no a develop." },
          {
            "texto": "En Gitflow las modificaciones se fusionan en develop y este se fusiona sobre master, siempre."
          },
          { "texto": "Por convenio. Técnicamente no hace falta." },
          {
            "texto": "Porque el cambio es necesario en producción y debe estar disponible en master, pero; además, hay que incorporarlo en cualquier prueba que se esté realizando en el desarrollo de la siguiente versión."
          }
        ],
        "correct": 3,
        "feedback": "De lo contrario, los entornos de pruebas pueden no comportarse igual que producción."
      },
      {
        "pregunta": "¿Se puede implementar feature branching con GitHub sin usar pull requests?",
        "resp": [
          { "texto": "No, en GitHub es obligatorio usar pull requests." },
          {
            "texto": "Sí, porque GitHub ofrece la funcionalidad de abrir pull requests dentro de un mismo repositorio, que son otro tipo de pull requests."
          },
          {
            "texto": "Sí, feature branching puede implementarse en cualquier tipo de sistema de control de versiones centralizado o distribuido."
          },
          { "texto": "B y C." }
        ],
        "correct": 2,
        "feedback": "GitHub ofrece todas las funcionalidades de un servidor de Git y, por tanto, soporta un flujo que funcione sobre Git."
      },
      {
        "pregunta": "¿Cómo se crea un fork en GitHub?",
        "resp": [
          {
            "texto": "En la interfaz de GitHub, haciendo clic sobre el botón Fork."
          },
          { "texto": "Con git fork new." },
          { "texto": "Con git clone --fork ." },
          {
            "texto": "En la interfaz de GitHub, en el asistente de New repository, hay que seleccionar que se trata de un fork e indicar el repositorio principal."
          }
        ],
        "correct": 0,
        "feedback": "Los forks no son más que clones, pero GitHub ofrece una funcionalidad adicional para identificar que un repositorio es un fork de otro."
      },
      {
        "pregunta": "Relaciona cada flujo con su característica.",
        "resp": [],
        "options": [
          "Flujo centralizado.",
          "Feature branching workflow.",
          "Flujo de GitLab.",
          "Forking workflow."
        ],
        "rels": [
          "Hay una única rama.",
          "Hay una rama principal y una rama nueva para cada cambio que haya que implementar.",
          "Cada rama corresponde con un entorno de despliegue.",
          "Requiere una plataforma que soporte el concepto de pull request."
        ],
        "feedback": "Respuesta correctaRespuesta correcta"
      },
      {
        "pregunta": "Un desarrollador no tiene acceso de escritura al repositorio principal repo y ha trabajado en una rama new-feature en su fork. Al abrir la pull request, ¿cuál es la rama de origen y cuál es la de destino?",
        "resp": [
          {
            "texto": "El origen es repo:new-feature y el destino es repo:master."
          },
          {
            "texto": "El origen es fork/repo:new-feature y el destino es repo:master."
          },
          {
            "texto": "El origen es fork/repo:new-feature y el destino es repo:new-feature."
          },
          {
            "texto": "El origen es repo:new-feature y el destino es fork/repo:master."
          }
        ],
        "correct": 2,
        "feedback": "La rama de trabajo existe en el fork, no en el repositorio principal. El destino es la rama principal del repositorio original."
      },
      {
        "pregunta": "¿Qué significa que un repositorio local pueda tener varios repositorios remotos?",
        "resp": [
          {
            "texto": "En un sistema distribuido un repositorio puede intercambiar ramas y commits con cualquier otro repositorio. Estos otros repositorios se consideran remotos, y puede definirse más de uno."
          },
          {
            "texto": "Lo normal es que haya un único repositorio remoto: el fork del usuario."
          },
          {
            "texto": "Git solo permite un repositorio remoto, pero Subversion permite varios."
          },
          { "texto": "Ninguna de las anteriores." }
        ],
        "correct": 0,
        "feedback": "Además, el usuario puede tener acceso de lectura sobre unos y de lectura y escritura sobre otros."
      },
      {
        "pregunta": "En Gitflow, ¿por qué se dice que cada fusión sobre master es una nueva versión?",
        "resp": [
          {
            "texto": "No es cierto; en Gitflow se trabaja únicamente con master."
          },
          {
            "texto": "Porque se añade una etiqueta con el número de la versión a esos commits."
          },
          {
            "texto": "Por convenio, en master no se añaden commits que no se hayan planificado para una versión concreta."
          },
          {
            "texto": "Por convenio, las ramas de características nuevas se fusionan sobre master justo antes de preparar la nueva versión. Se fusionan todas juntas, por lo que master está listo para producción."
          }
        ],
        "correct": 2,
        "feedback": "El trabajo de preparación de la versión se ha llevado a cabo en las ramas release-* o hotfix-*. Una rama release-* puede tener commits que no estén listos para producción, pero cuando su HEAD está lista, se fusiona sobre master, por lo que esta también estará lista para producción."
      }
    ]
  },
  {
    "nombre": "test04",
    "test": []
  },
  {
    "nombre": "test05",
    "test": []
  },
  {
    "nombre": "test06",
    "test": []
  },
  {
    "nombre": "test07",
    "test": []
  },
  {
    "nombre": "test08",
    "test": []
  },
  {
    "nombre": "test09",
    "test": []
  },
  {
    "nombre": "test10",
    "test": []
  }
]
